#version 420

// On re√ßoit des triangles
// On renvoit des triangles

layout ( points ) in;
layout ( triangle_strip, max_vertices=3 ) out;

in vec3 gs_normal[1];


vec3 light_position = vec3(-10.0, -10.0, -50.0);
vec3 object_color = vec3(0.0, 0.0, 1.0);
float normal_length = 1.5;

uniform float anim_time;

out vec3 color;

// Pseudo-random number generator function
float pseudoRandom(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {

	/*vec4 origin = gl_in[0].gl_Position;
	vec3 normal_inter = gs_normal[0] * 15.0;

	color = vec3(0.0, 1.0, 0.0);

    gl_Position = origin + vec4(2.0, 0.0, 0.0, 0.0);
    EmitVertex();

	gl_Position = origin + vec4(-2.0, 0.0, 0.0, 0.0);
	EmitVertex();

	gl_Position = origin + vec4(sin(anim_time * 0.8) * 15.0, 50.0, 0.0, 1.0);
	EmitVertex();

    EndPrimitive();*/

	vec4 origin = gl_in[0].gl_Position;
	color = vec3(0.0, 1.0, 0.0);

	const vec4 grass_vertices[3] = vec4[3](
		origin + vec4(2.0, 0.0, 0.0, 0.0),
		origin + vec4(-2.0, 0.0, 0.0, 0.0),
		origin + vec4(0.0, 50.0, 0.0, 1.0)
	);

	for (int i = 0; i < 3; ++i) {
        vec4 position = grass_vertices[i];

        // Calculate wind effect
		vec3 windDirection = vec3(-1.0f, 0.0f, -0.0);
		float randomFactor = pseudoRandom(position.xy);
        vec3 windEffect = sin(anim_time * 0.8 + randomFactor) * 15.0 * windDirection;
        //vec3 turbulence = noise(anim_time * turbulenceScale) * turbulenceIntensity;

        // Apply wind effect and turbulence to vertex position
		if (i==2)
        	position.xyz += windEffect;

        // Emit the modified vertex
        gl_Position = position;
        EmitVertex();
    }

    EndPrimitive();
}
